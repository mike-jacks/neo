package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"fmt"
	"strings"

	"github.com/mike-jacks/neo/generated"
	"github.com/mike-jacks/neo/model"
	"github.com/mike-jacks/neo/utils"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// CreateSchemaNode is the resolver for the createSchemaNode field.
func (r *mutationResolver) CreateSchemaNode(ctx context.Context, sourceSchemaNodeName *string, createSchemaNodeInput model.CreateSchemaNodeInput) (*model.SchemaNode, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	// Ensure uniqueness constraint on SchemaNode name
	constraintQuery := "CREATE CONSTRAINT unique_schema_node_name_domain IF NOT EXISTS FOR (n:SchemaNode) REQUIRE (n.name,n.domain) IS UNIQUE"
	if err := utils.CreateConstraint(ctx, r.Driver, []*string{&constraintQuery}); err != nil {
		return nil, fmt.Errorf("failed to create constraint: %w", err)
	}

	schemaNode := &model.SchemaNode{
		Name:   strings.TrimSpace(strings.ToUpper(createSchemaNodeInput.Name)),
		Domain: strings.TrimSpace(strings.ToUpper(createSchemaNodeInput.Domain)),
	}

	var query string
	parameters := map[string]interface{}{
		"name":   schemaNode.Name,
		"domain": schemaNode.Domain,
	}

	if sourceSchemaNodeName == nil {
		query = `
			CREATE (n:SchemaNode {name: $name, domain: $domain})
			RETURN n
		`
	} else {
		query = `
			MATCH (sourceNode:SchemaNode {name: $sourceSchemaNodeName})
			CREATE (n:SchemaNode {name: $name, domain: $domain})
			CREATE (sourceNode)<-[:BELONGS_TO]-(n)
			RETURN n
		`
		parameters["sourceSchemaNodeName"] = strings.TrimSpace(strings.ToUpper(*sourceSchemaNodeName))
	}

	var newSchemaNode *model.SchemaNode

	_, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
		result, err := tx.Run(ctx, query, parameters)
		if err != nil {
			return nil, err
		}

		record, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to create node: %w", err)
		}

		node, ok := record.Values[0].(neo4j.Node)
		if !ok {
			return nil, fmt.Errorf("unexpected result type: %T", record.Values[0])
		}

		newSchemaNode := &model.SchemaNode{
			Name:   node.Props["name"].(string),
			Domain: node.Props["domain"].(string),
		}

		return newSchemaNode, nil
	})

	if err != nil {
		return nil, err
	}

	return newSchemaNode, nil
}

// UpdateSchemaNode is the resolver for the updateSchemaNode field.
func (r *mutationResolver) UpdateSchemaNode(ctx context.Context, domain string, name string, updateSchemaNodeInput model.UpdateSchemaNodeInput) (*model.SchemaNode, error) {
	domain = strings.TrimSpace(strings.ToUpper(domain))
	name = strings.TrimSpace(strings.ToUpper(name))

	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	var updatedNode *model.SchemaNode

	_, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
		query := `
			MATCH (n:SchemaNode {name: $origName, domain: $origDomain})
		`
		setClause := []string{}
		parameters := map[string]interface{}{
			"origName":   name,
			"origDomain": domain,
		}

		if updateSchemaNodeInput.Name != nil {
			setClause = append(setClause, "n.name = $newName")
			parameters["newName"] = strings.TrimSpace(strings.ToUpper(*updateSchemaNodeInput.Name))
		}

		if updateSchemaNodeInput.Domain != nil {
			setClause = append(setClause, "n.domain = $newDomain")
			parameters["newDomain"] = strings.TrimSpace(strings.ToUpper(*updateSchemaNodeInput.Domain))
		}

		if len(setClause) > 0 {
			query += "SET " + strings.Join(setClause, ", ")
		} else {
			return nil, fmt.Errorf("no fields to update")
		}

		query += " RETURN n"

		result, err := tx.Run(ctx, query, parameters)
		if err != nil {
			return nil, err
		}

		record, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("no node found or multiple nodes found: %v", err)
		}

		node, ok := record.Values[0].(neo4j.Node)
		if !ok {
			return nil, fmt.Errorf("unexpected result type: %T", record.Values[0])
		}

		updatedNode = &model.SchemaNode{
			Name:   node.Props["name"].(string),
			Domain: node.Props["domain"].(string),
		}

		return nil, nil
	})

	if err != nil {
		return nil, err
	}

	return updatedNode, nil
}

// DeleteSchemaNode is the resolver for the deleteSchemaNode field.
func (r *mutationResolver) DeleteSchemaNode(ctx context.Context, domain string, name string) (bool, error) {
	domain = strings.TrimSpace(strings.ToUpper(domain))
	name = strings.TrimSpace(strings.ToUpper(name))

	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	result, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
		query := `
			MATCH (n:SchemaNode {name: $name, domain: $domain})
			WITH n, COUNT(n) > 0 AS nodeExists
			DETACH DELETE n
			RETURN nodeExists
		`
		parameters := map[string]interface{}{
			"name":   name,
			"domain": domain,
		}
		result, err := tx.Run(ctx, query, parameters)
		if err != nil {
			return false, err
		}

		record, err := result.Single(ctx)
		if err != nil {
			if err.Error() == "Result contains no more records" {
				return false, fmt.Errorf("node with name '%s' and domain '%s' does not exist", name, domain)
			}
			return false, err
		}
		nodeExists, ok := record.Get("nodeExists")
		if !ok {
			return false, fmt.Errorf("node with name '%s' and domain '%s' does not exist", name, domain)
		}
		return nodeExists.(bool), nil
	})

	if err != nil {
		return false, err
	}

	nodeExists := result.(bool)
	if !nodeExists {
		return false, fmt.Errorf("node with name '%s' and domain '%s' does not exist", name, domain)
	}

	return true, nil
}

// CreateSchemaProperty is the resolver for the createSchemaProperty field.
func (r *mutationResolver) CreateSchemaProperty(ctx context.Context, createSchemaPropertyInput model.CreateSchemaPropertyInput) (*model.SchemaProperty, error) {
	panic(fmt.Errorf("not implemented: CreateSchemaProperty - createSchemaProperty"))
}

// UpdateSchemaProperty is the resolver for the updateSchemaProperty field.
func (r *mutationResolver) UpdateSchemaProperty(ctx context.Context, domain string, schemaNodeName string, schemaPropertyName string, schemaPropertyType string, updateSchemaPropertyInput model.UpdateSchemaPropertyInput) (*model.SchemaProperty, error) {
	panic(fmt.Errorf("not implemented: UpdateSchemaProperty - updateSchemaProperty"))
}

// DeleteSchemaProperty is the resolver for the deleteSchemaProperty field.
func (r *mutationResolver) DeleteSchemaProperty(ctx context.Context, domain string, schemaNodeName string, schemaPropertyName string, schemaPropertyType string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSchemaProperty - deleteSchemaProperty"))
}

// CreateSchemaRelationship is the resolver for the createSchemaRelationship field.
func (r *mutationResolver) CreateSchemaRelationship(ctx context.Context, createSchemaRelationshipInput model.CreateSchemaRelationshipInput) (*model.SchemaRelationship, error) {
	panic(fmt.Errorf("not implemented: CreateSchemaRelationship - createSchemaRelationship"))
}

// UpdateSchemaRelationship is the resolver for the updateSchemaRelationship field.
func (r *mutationResolver) UpdateSchemaRelationship(ctx context.Context, domain string, schemaNodeName string, schemaRelationshipName string, updateSchemaRelationshipInput model.UpdateSchemaRelationshipInput) (*model.SchemaRelationship, error) {
	panic(fmt.Errorf("not implemented: UpdateSchemaRelationship - updateSchemaRelationship"))
}

// DeleteSchemaRelationship is the resolver for the deleteSchemaRelationship field.
func (r *mutationResolver) DeleteSchemaRelationship(ctx context.Context, domain string, schemaNodeName string, schemaRelationshipName string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSchemaRelationship - deleteSchemaRelationship"))
}

// CreateSchemaLabel is the resolver for the createSchemaLabel field.
func (r *mutationResolver) CreateSchemaLabel(ctx context.Context, createSchemaLabelInput model.CreateSchemaLabelInput) (*model.SchemaLabel, error) {
	panic(fmt.Errorf("not implemented: CreateSchemaLabel - createSchemaLabel"))
}

// UpdateSchemaLabel is the resolver for the updateSchemaLabel field.
func (r *mutationResolver) UpdateSchemaLabel(ctx context.Context, domain string, schemaNodeName string, schemaLabelName string, updateSchemaLabelInput model.UpdateSchemaLabelInput) (*model.SchemaLabel, error) {
	panic(fmt.Errorf("not implemented: UpdateSchemaLabel - updateSchemaLabel"))
}

// DeleteSchemaLabel is the resolver for the deleteSchemaLabel field.
func (r *mutationResolver) DeleteSchemaLabel(ctx context.Context, domain string, schemaNodeName string, schemaLabelName string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSchemaLabel - deleteSchemaLabel"))
}

// GetSchemaNode is the resolver for the getSchemaNode field.
func (r *queryResolver) GetSchemaNode(ctx context.Context, domain string, name string) (*model.SchemaNode, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNode - getSchemaNode"))
}

// GetSchemaNodes is the resolver for the getSchemaNodes field.
func (r *queryResolver) GetSchemaNodes(ctx context.Context, domain string) ([]*model.SchemaNode, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNodes - getSchemaNodes"))
}

// GetSchemaNodeProperty is the resolver for the getSchemaNodeProperty field.
func (r *queryResolver) GetSchemaNodeProperty(ctx context.Context, domain string, schemaNodeName string, schemaPropertyName string, schemaPropertyType string) (*model.SchemaProperty, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNodeProperty - getSchemaNodeProperty"))
}

// GetSchemaNodeProperties is the resolver for the getSchemaNodeProperties field.
func (r *queryResolver) GetSchemaNodeProperties(ctx context.Context, domain string, schemaNodeName string) ([]*model.SchemaProperty, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNodeProperties - getSchemaNodeProperties"))
}

// GetSchemaNodeRelationship is the resolver for the getSchemaNodeRelationship field.
func (r *queryResolver) GetSchemaNodeRelationship(ctx context.Context, domain string, schemaNodeName string, schemaRelationshipName string) (*model.SchemaRelationship, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNodeRelationship - getSchemaNodeRelationship"))
}

// GetSchemaNodeRelationships is the resolver for the getSchemaNodeRelationships field.
func (r *queryResolver) GetSchemaNodeRelationships(ctx context.Context, domain string, schemaNodeName string) ([]*model.SchemaRelationship, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNodeRelationships - getSchemaNodeRelationships"))
}

// GetSchemaNodeLabel is the resolver for the getSchemaNodeLabel field.
func (r *queryResolver) GetSchemaNodeLabel(ctx context.Context, domain string, schemaNodeName string, schemaLabelName string) (*model.SchemaLabel, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNodeLabel - getSchemaNodeLabel"))
}

// GetSchemaNodeLabels is the resolver for the getSchemaNodeLabels field.
func (r *queryResolver) GetSchemaNodeLabels(ctx context.Context, domain string, schemaNodeName string) ([]*model.SchemaLabel, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNodeLabels - getSchemaNodeLabels"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
