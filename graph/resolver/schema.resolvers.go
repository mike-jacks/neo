package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"fmt"
	"log"

	"github.com/mike-jacks/neo/graph/generated"
	"github.com/mike-jacks/neo/graph/generated/model"
	"github.com/mike-jacks/neo/tools"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// CreateSchemaNode is the resolver for the createSchemaNode field.
func (r *mutationResolver) CreateSchemaNode(ctx context.Context, sourceSchemaNodeName *string, createSchemaNodeInput model.CreateSchemaNodeInput) (*model.SchemaNode, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	// Ensure uniqueness constraint on SchemaNode name
	constraintQueries := []string{
		"CREATE CONSTRAINT unique_schema_node_name IF NOT EXISTS FOR (n:SchemaNode) REQUIRE (n.name) IS UNIQUE",
		"CREATE CONSTRAINT unique_schema_property_name IF NOT EXISTS FOR (n:SchemaProperty) REQUIRE (n.name, n.domain, n.parentName) IS UNIQUE",
		"CREATE CONSTRAINT unique_schema_label_name IF NOT EXISTS FOR (n:SchemaLabel) REQUIRE (n.name, n.domain, n.parentName) IS UNIQUE",
		"CREATE CONSTRAINT unique_schema_relationship_name IF NOT EXISTS FOR (n:SchemaRelationship) REQUIRE (n.name, n.domain, n.parentName) IS UNIQUE",
	}
	for _, constraintQuery := range constraintQueries {
		_, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
			_, err := tx.Run(ctx, constraintQuery, nil)
			return nil, err
		})
		if err != nil {
			return nil, err
		}
	}

	schemaNode := model.SchemaNode{
		Name:       createSchemaNodeInput.Name,
		Domain:     createSchemaNodeInput.Domain,
		Type:       createSchemaNodeInput.Type,
		Labels:     make([]*model.SchemaLabel, len(createSchemaNodeInput.Labels)),
		Properties: make([]*model.SchemaProperty, len(createSchemaNodeInput.Properties)),
	}

	properties := make([]map[string]interface{}, len(createSchemaNodeInput.Properties))
	for i, property := range createSchemaNodeInput.Properties {
		schemaNode.Properties[i] = &model.SchemaProperty{
			Name:       property.Name,
			Type:       property.Type,
			Domain:     property.Domain,
			ParentName: property.ParentName,
		}
		properties[i] = map[string]interface{}{
			"name":       schemaNode.Properties[i].Name,
			"type":       schemaNode.Properties[i].Type,
			"domain":     schemaNode.Properties[i].Domain,
			"parentName": schemaNode.Properties[i].ParentName,
		}
	}

	labels := make([]map[string]interface{}, len(createSchemaNodeInput.Labels))
	for i, label := range createSchemaNodeInput.Labels {
		schemaNode.Labels[i] = &model.SchemaLabel{
			Name:       label.Name,
			Domain:     label.Domain,
			ParentName: label.ParentName,
		}
		labels[i] = map[string]interface{}{
			"name":       schemaNode.Labels[i].Name,
			"domain":     schemaNode.Labels[i].Domain,
			"parentName": schemaNode.Labels[i].ParentName,
		}
	}

	_, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
		query := `
			// Step 1: Attempt to match the source node
			OPTIONAL MATCH (sourceNode:SchemaNode {name: $sourceSchemaNodeName})

			WITH COALESCE(sourceNode, NULL) AS sourceNode, $name AS name, $domain AS domain, $type AS type, $properties AS properties, $labels AS labels

			// Step 2: Create the new SchemaNode
			CREATE (n:SchemaNode {name: $name, domain: $domain, type: $type})
			CREATE (e:test {name: "This is a test before properties"})

			WITH n, sourceNode, labels, properties

			// Step 3: Create the properties for the new SchemaNode
			FOREACH (property IN properties |
				MERGE (p:SchemaProperty {name: property.name, domain: property.domain, type: property.type, parentName: property.parentName})
				MERGE (n)-[:HAS_PROPERTY]->(p)
			)
			WITH n, sourceNode, labels
			// Step 4: Create the labels for the new SchemaNode
			FOREACH (label IN labels |
				MERGE (l:SchemaLabel {name: label.name, domain: label.domain, parentName: label.parentName})
				MERGE (n)-[:HAS_LABEL]->(l)
			)

			// Step 5: Create the relationship between the source node and the new SchemaNode
			FOREACH (_ IN CASE WHEN sourceNode IS NOT NULL THEN [1] ELSE [] END |
				CREATE (sourceNode)<-[:BELONGS_TO]-(n)
			)
			WITH n, sourceNode
			// Step 6: Return the new SchemaNode
			RETURN n
		`

		parameters := map[string]interface{}{
			"name":                 schemaNode.Name,
			"domain":               schemaNode.Domain,
			"type":                 schemaNode.Type,
			"labels":               labels,
			"properties":           properties,
			"sourceSchemaNodeName": tools.DereferenceOrNil(sourceSchemaNodeName),
		}

		_, err := tx.Run(ctx, query, parameters)
		if err != nil {
			return nil, err
		}

		return schemaNode, nil
	})

	if err != nil {
		return nil, err
	}

	return &schemaNode, nil
}

// CreateSchemaProperty is the resolver for the createSchemaProperty field.
func (r *mutationResolver) CreateSchemaProperty(ctx context.Context, schemaNodeName string, domain string, createSchemaPropertyInput model.CreateSchemaPropertyInput) (*model.SchemaProperty, error) {
	panic(fmt.Errorf("not implemented: CreateSchemaProperty - createSchemaProperty"))
}

// CreateSchemaRelationship is the resolver for the createSchemaRelationship field.
func (r *mutationResolver) CreateSchemaRelationship(ctx context.Context, createSchemaRelationshipInput model.CreateSchemaRelationshipInput) (*model.SchemaRelationship, error) {
	panic(fmt.Errorf("not implemented: CreateSchemaRelationship - createSchemaRelationship"))
}

// UpdateSchemaNode is the resolver for the updateSchemaNode field.
func (r *mutationResolver) UpdateSchemaNode(ctx context.Context, name string, domain string, updateSchemaNodeInput model.UpdateSchemaNodeInput) (*model.SchemaNode, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	labels := make([]map[string]interface{}, len(updateSchemaNodeInput.Labels))
	for i, label := range updateSchemaNodeInput.Labels {
		labels[i] = map[string]interface{}{
			"name":       label.Name,
			"domain":     label.Domain,
			"parentName": label.ParentName,
		}
	}

	properties := make([]map[string]interface{}, len(updateSchemaNodeInput.Properties))
	for i, property := range updateSchemaNodeInput.Properties {
		properties[i] = map[string]interface{}{
			"name":       property.Name,
			"type":       property.Type,
			"domain":     property.Domain,
			"parentName": property.ParentName,
		}
	}

	_, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
		query := `
			MATCH (n:SchemaNode {name: $name, domain: $domain})
			WITH n, $newName AS newName, $newDomain AS newDomain, $newType AS newType, $newLabels AS newLabels, $newProperties AS newProperties
			FOREACH (_ IN CASE WHEN n IS NOT NULL THEN [1] ELSE [] END |
				SET n.name = COALESCE(newName, n.name),
					n.domain = COALESCE(newDomain, n.domain),
					n.type = COALESCE(newType, n.type)
			)
			WITH n, newLabels, newProperties
			FOREACH (label IN newLabels |
				MERGE (l:SchemaLabel {name: label.name, domain: label.domain, parentName: label.parentName})
				MERGE (n)-[:HAS_LABEL]->(l)
			)
			WITH n, newProperties
			FOREACH (property IN newProperties |
				MERGE (p:SchemaProperty {name: property.name, domain: property.domain, type: property.type, parentName: property.parentName})
				MERGE (n)-[:HAS_PROPERTY]->(p)
			)
			RETURN n
	`
		parameters := map[string]interface{}{
			"name":          name,
			"domain":        domain,
			"newName":       updateSchemaNodeInput.Name,
			"newDomain":     updateSchemaNodeInput.Domain,
			"newType":       updateSchemaNodeInput.Type,
			"newLabels":     labels,
			"newProperties": properties,
		}
		result, err := tx.Run(ctx, query, parameters)
		if err != nil {
			return nil, err
		}
		return result, nil
	})
	if err != nil {
		return nil, err
	}

	nodeResult, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (interface{}, error) {
		query := `
			MATCH (n:SchemaNode {name: $name, domain: $domain})
			OPTIONAL MATCH (n)-[:HAS_LABEL]->(l:SchemaLabel)
			OPTIONAL MATCH (n)-[:HAS_PROPERTY]->(p:SchemaProperty)
			WITH n, collect(DISTINCT l {name: l.name, domain: l.domain, parentName: l.parentName}) AS labels,
			collect(DISTINCT p {name: p.name, type: p.type, domain: p.domain, parentName: p.parentName}) AS properties
			RETURN n {.*, labels: labels, properties: properties} AS node
			
		`
		parameters := map[string]interface{}{
			"name":   name,
			"domain": domain,
		}
		result, err := tx.Run(ctx, query, parameters)
		if err != nil {
			log.Printf("Error retrieving updated SchemaNode: %v", err)
			return nil, err
		}
		record, err := result.Single(ctx)
		if err != nil {
			log.Printf("Error retrieving single record: %v", err)
			return nil, err
		}
		return record, nil
	})
	if err != nil {
		return nil, err
	}

	log.Printf("nodeResult: %v", nodeResult)
	log.Printf("nodeResult type: %T", nodeResult)

	nodeRecord, ok := nodeResult.(*neo4j.Record)
	if !ok {
		log.Printf("Error asserting nodeResult to neo4j.Record: %v", nodeResult)
		return nil, fmt.Errorf("error asserting nodeResult to neo4j.Record")
	}

	log.Printf("nodeRecord: %v", nodeRecord)
	log.Printf("nodeRecord type: %T", nodeRecord.Values[0])

	resultNode, ok := nodeRecord.Values[0].(map[string]interface{})
	if !ok {
		log.Printf("Error asserting resultNode to map[string]interface{}: %v", nodeRecord.Values[0])
		return nil, fmt.Errorf("error asserting resultNode to map[string]interface{}")
	}

	resultLabels, ok := resultNode["labels"].([]interface{})
	if !ok {
		log.Printf("Error asserting resultLabels to []interface{}: %v", resultNode["labels"])
		return nil, fmt.Errorf("error asserting resultLabels to []interface{}")
	}
	resultProperties, ok := resultNode["properties"].([]interface{})
	if !ok {
		log.Printf("Error asserting resultProperties to []interface{}: %v", resultNode["properties"])
		return nil, fmt.Errorf("error asserting resultProperties to []interface{}")
	}

	schemaNode := &model.SchemaNode{
		Name:       resultNode["name"].(string),
		Domain:     resultNode["domain"].(string),
		Type:       resultNode["type"].(string),
		Labels:     make([]*model.SchemaLabel, len(resultLabels)),
		Properties: make([]*model.SchemaProperty, len(resultProperties)),
	}

	for i, label := range resultLabels {
		labelMap, ok := label.(map[string]interface{})
		if !ok {
			log.Printf("Error asserting label to map[string]interface{}: %v", label)
			return nil, fmt.Errorf("error asserting label to map[string]interface{}")
		}
		schemaNode.Labels[i] = &model.SchemaLabel{
			Name:       labelMap["name"].(string),
			Domain:     labelMap["domain"].(string),
			ParentName: labelMap["parentName"].(string),
		}
	}

	for i, property := range resultProperties {
		log.Printf("property type: %T", property)
		propertyNode, ok := property.(map[string]interface{})
		if !ok {
			log.Printf("Error asserting property to map[string]interface{}: %v", property)
			return nil, fmt.Errorf("error asserting property to map[string]interface{}")
		}
		schemaNode.Properties[i] = &model.SchemaProperty{
			Name:       propertyNode["name"].(string),
			Type:       propertyNode["type"].(string),
			Domain:     propertyNode["domain"].(string),
			ParentName: propertyNode["parentName"].(string),
		}
	}

	return schemaNode, nil
}

// UpdateSchemaProperty is the resolver for the updateSchemaProperty field.
func (r *mutationResolver) UpdateSchemaProperty(ctx context.Context, name string, typeArg string, domain string, updateSchemaPropertyInput model.UpdateSchemaPropertyInput) (*model.SchemaProperty, error) {
	panic(fmt.Errorf("not implemented: UpdateSchemaProperty - updateSchemaProperty"))
}

// UpdateSchemaRelationship is the resolver for the updateSchemaRelationship field.
func (r *mutationResolver) UpdateSchemaRelationship(ctx context.Context, name string, domain string, updateSchemaRelationshipInput model.UpdateSchemaRelationshipInput) (*model.SchemaRelationship, error) {
	panic(fmt.Errorf("not implemented: UpdateSchemaRelationship - updateSchemaRelationship"))
}

// DeleteSchemaNode is the resolver for the deleteSchemaNode field.
func (r *mutationResolver) DeleteSchemaNode(ctx context.Context, name string, domain string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSchemaNode - deleteSchemaNode"))
}

// DeleteSchemaProperty is the resolver for the deleteSchemaProperty field.
func (r *mutationResolver) DeleteSchemaProperty(ctx context.Context, name string, typeArg string, domain string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSchemaProperty - deleteSchemaProperty"))
}

// DeleteSchemaRelationship is the resolver for the deleteSchemaRelationship field.
func (r *mutationResolver) DeleteSchemaRelationship(ctx context.Context, name string, domain string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSchemaRelationship - deleteSchemaRelationship"))
}

// GetSchemaNodes is the resolver for the getSchemaNodes field.
func (r *queryResolver) GetSchemaNodes(ctx context.Context, domain string) ([]*model.SchemaNode, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNodes - getSchemaNodes"))
}

// GetSchemaProperties is the resolver for the getSchemaProperties field.
func (r *queryResolver) GetSchemaProperties(ctx context.Context, schemaNodeName string, domain string) ([]*model.SchemaProperty, error) {
	panic(fmt.Errorf("not implemented: GetSchemaProperties - getSchemaProperties"))
}

// GetSchemaRelationships is the resolver for the getSchemaRelationships field.
func (r *queryResolver) GetSchemaRelationships(ctx context.Context, schemaNodeName string, domain string) ([]*model.SchemaRelationship, error) {
	panic(fmt.Errorf("not implemented: GetSchemaRelationships - getSchemaRelationships"))
}

// GetSchemaNode is the resolver for the getSchemaNode field.
func (r *queryResolver) GetSchemaNode(ctx context.Context, domain string, name string) (*model.SchemaNode, error) {
	panic(fmt.Errorf("not implemented: GetSchemaNode - getSchemaNode"))
}

// GetSchemaProperty is the resolver for the getSchemaProperty field.
func (r *queryResolver) GetSchemaProperty(ctx context.Context, domain string, name string, typeArg string, parentName string) (*model.SchemaProperty, error) {
	panic(fmt.Errorf("not implemented: GetSchemaProperty - getSchemaProperty"))
}

// GetSchemaRelationship is the resolver for the getSchemaRelationship field.
func (r *queryResolver) GetSchemaRelationship(ctx context.Context, domain string, name string, parentName string) (*model.SchemaRelationship, error) {
	panic(fmt.Errorf("not implemented: GetSchemaRelationship - getSchemaRelationship"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
